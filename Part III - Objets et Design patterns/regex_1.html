<!--
                                                        Les expressions r√©guli√®res

Les expressions r√©guli√®res, souvent surnomm√©es "regex", trouvent leur place dans bon nombre de langages, comme le Perl, le
Python ou encore le PHP.

Les regex sont une sorte de langage "√† part" qui sert √† manipuler les cha√Ænes de caract√®res. Voici quelques exemples de ce que
les regex sont capables de faire :

    -   V√©rifier si une URL entr√©e par l'utilisateur ressemble effectivement √† une URL. On peut faire pareil pour les adresses
            e-mail, les num√©ros de t√©l√©phone et toute autre syntaxe structur√©e.
    -   Rechercher et extraire des informations hors d'une cha√Æne de caract√®res (bien plus puissant que de jouer avec indexOf()
            et substring())
    -   Supprimer certains caract√®res, et au besoin les remplacer par d'autres
    -   Pour les forums, convertir des langages comme le BBCode en HTML lors des pr√©visualisations pendant la framme
    -   Et bien d'autres choses encore

I./ Les regex en JavaScript

La syntaxe des regex en JavaScript d√©coule de la syntaxe des regex du langage Perl. C'est un langage tr√®s utilis√© pour 
l'analyse et le traitement des donn√©es textuelles (des cha√Ænes de caract√®res, donc), en raison de la puissance de ses
expressions r√©guli√®res. Le JavaScript h√©rite donc d'une partie de la puissance des regex de Perl.

1.) Utilisation

Les regex ne s'utilisent pas seuls, et il y a deux mani√®res de s'en servir : soit par le biais de RegExp qui est l'objet 
qui g√®re les expressions r√©guli√®res, soit par le biais de certaines m√©thodes de l'objet String :

    -   match() : retourne un tableau contenant toutes les occurences recherch√©es
    -   search() : retourne la position d'une portion de texte (semblable √† indexOf() mais avec une regex)
    -   split() : la fameuse m√©thode split(), mais avec une regex en param√®tre
    -   replace() : effectue un rechercher / remplacer

On ne va pas commencer par ces quatre m√©thodes car on va d'abord se plonger dans l'√©tude des regex : les √©crire et les tester.
Pour ce faire, on va s'en servir de la m√©thode test() fournie par l'objet RegExp. L'instanciation d'un objet RegExp se fait
comme ceci :

var myRegex = /contenu_√†_rechercher/;

Cela ressemble √† une cha√Æne de caract√®res, √† l'excetpion pr√®s qu'elle est encadr√©e par deux slashs au lieu des apostrophes ou
guillemets traditionnels. 

Si ma regex contient elle-m√™me des slashs, il faudra les √©chapper en utilisant des anti-slash comme ceci :

var regex_1 = /contenu_\/_content/;             // ==> OK !
var regex_bidon = /contenu_/_content/;          // ==> FAUX ! (car le slash n'est pas √©chapp√©)

L'utilisation de la m√©thode test() est tr√®s simple. En cas de r√©ussite de test, elle renvoie true; dans le cas contraire,
elle renvoie false.

Exemple :

if(myRegex.test('Cha√Æne de caract√®res dans laquelle effectuer des recherches'){
    //Code ex√©cut√© en cas de r√©ussite du test
} else {
    //Code ex√©cut√© en cas d'√©chec
}

Pour mes tests, je peux utiliser une syntaxe plus concise, comme ceci :

if(/contenu_√†_rechercher/.test('Cha√Æne de caract√®res bla bla bla'))
    //code

II./ Rechercher des mots

1.) Un mot, options et companie

Effectuons donc une recherche pour tester si une phrase contient le mot "raclette" :

if(/raclette/.test('Je mangerais bien une raclette savoyarde'))
    alert('Tiens, √ßa parle de raclette');
else
    alert('Pas de raclette √† l\'horizon');

Si on change notre mot un peu, en mettant un 'R' majucule, le test renverra faux, car le mot "raclette" pr√©sent dans la phrase
ne comporte pas de majuscule. 

Il est possible, gr√¢ce aux options, de dire √† la regex d'ignorer la casse, ie de rechercher indiff√©remment des majuscules ou
des minuscules. Cette option s'appelle i, et comme chaque option (on en verra d'autres), elle se place juste apr√®s le slash de 
fermeture de ma regex, comme ceci :

/raclette/i

Avec cette option, la regex reste utilisable comme on l'a vu pr√©c√©demment :
if(/Raclette/i.test('Je mangerais une raclette')
    //code
else
    //code

On peut aussi √©crire une regex pour tester si, parmi deux mots ou plus, au moins un est cotnenu ou pas dans la cha√Æne de
caract√®res : gr√¢ce √† l'op√©rateur "OU", repr√©sent√© par la barre verticale pipe |. Son utilisation est simple, puisqu'il suffit
de la placer entre chaque mot recherch√©, comme ceci :

if(/Raclette|Tartiflette/i.test('Je mangerais bien une tartiflette savoyarde'))
    //code

La recherche peut bien √©videmment inclure plus de deux possibilit√©s :

/Raclette|Tartiflette|Fondue|K√©bab|Croziflette/i

Avec cette regex, on saura si la phrase contient au moins une de ces cinq sp√©cialit√©s savoyardes !

2.) D√©but et fin de cha√Æne

Les symboles ^ et $ permettent respectivement de repr√©senter le d√©but et la fin d'une cha√Æne de caract√®res. Si un de
ces symboles est pr√©sent, il indique √† la regex que ce qui est recherch√© commence ou termine la cha√Æne. Cela
d√©limite la cha√Æne en quelque sorte :

/^Raclette savoyarde$/

Voici un tableau avec divers tests qui sont effectu√©s pour montrer l'utilisation de ces deux symboles :
__________________________________________________________________
CHA√éNE                  |   Regex                   |   R√©sultat |
------------------------------------------------------------------
Raclette savoyarde      |   /^Raclette savoyarde$/  |   true
Une raclette savoyarde  |   /^Raclette/             |   false
Une raclette savoyarde  |   /savoyarde$/            |   true
Une raclette savoyarde! |   /raclette savoyarde$/   |   false
------------------------------------------------------------------

III./ Les caract√®res et leurs classes

1.) Choix parmi plusieurs lettres

Il s'agira ici de classes de caract√®res qui permettent de sp√©cifier plusieurs caract√®res ou types de caract√®res √† 
rechercher. Cela reste encore assez simple :

/gr[ao]s/

Une classe de caract√®res est √©crite entre crochets et sa signification est simple : une des lettes qui se trouve √† 
l'int√©rieur des crochets peut convenir. 

Beaucoup de caract√®res peuvent √™tre utilis√©s au sein d'une classe :

/gr[a√®io]s/

Ici, la regex cherchera les mots "gras", "gr√®s", "gris" et "gros".

Ref script

2.) Les intervalles de caract√®res

Toujours au sein des classes de caract√®res, il est possible de sp√©cifier un intervalle de caract√®res. Si l'on veut trouver
les lettres allant de 'a' √† 'o', on √©crira [a-o]. Si n'importe quelle lettre peut convenir, il est inutile de les citer 
toutes : ==> [a-z] suffit.

Plusieurs intervalles peuvent √™tre √©crits au sein d'une m√™me classe. Ainsi, la classe [a-zA-A] va rechercher toutes les
lettres de l'alphabet, qu'elles soient majuscules ou minuscules. 

Pareil pour les intervalles de chiffres : la classe [0-9] recherchera un chiffre allant de 0 √† 9. 

Il est √©galement possible de combiner des chiffres et des lettres : [a-z0-9] trouvera une lettre minuscule ou un chiffre.

3.) Exclure des caract√®res

Si au sein d'une classe, on peut inclure des caract√®res, on peut aussi en exclure ! Pour ce faire, il suffit de faire figurer
un accent circonflexe au d√©but d'une classe, juste apr√®s le premier crochet. Exemples :

[^aeiouy] ==> ignorera les voyelles

L'exclusion d'un intervalle est possible aussi :

[^b-y]  ==> exclura les lettres allant de b √† y

Attention : il faut prendre en compte que la recherche n'ignore pas les caract√®res accentu√©s. Ainsi, [a-z] ne trouvera pas
√¢, √†, √Æ ou encore tout autre caract√®re accentu√©. S'il s'agit de trouver un caract√®re accentu√©, il faudra l'indiquer
explicitement : [a-z√¢√§√†√©√®√π√™√´√Æ√Ø√¥√∂√ß√±]. Toutefois, l'option i permet d'inclure aussi les variantes majuscules.

4.) Trouver un caract√®re quelconque

Le point permet de trouver n'importe quel caract√®re, √† 'exception des sauts de ligne (les retours √† la ligne). 
Exemple :

/gr.s/          ==> plus de 52 possibilit√©s (je crois)

IV./ Les quantificateurs

Les quantificateurs permettent de dire combien de fois un caract√®re peut √™tre r√©p√©t√©. Il est possible de dire qu'un
caract√®re peut √™tre recherch√© 0 ou 1 fois, 1 fois ou une infinit√© de fois, ou bien, avec les accolades, un nombre bien
d√©termin√© de fois.

1.) Les trois symboles quantificateurs

Voici les trois symboles quantificateurs :

    -   ? : ce symbole indique que le caract√®re qui le pr√©c√®de peut √™tre r√©p√©t√© 0 ou 1 fois
    -   + : ce symbole indique que le caract√®re qui le pr√©c√®de peut √™tre r√©p√©t√© 1 ou plusieurs fois
    -   * : ce symbole indique que le caract√®re qui le pr√©c√®de peut √™tre r√©p√©t√© 0, 1 ou plusieurs fois

Exemple : r√©f script



2.) Les accolades

A la place des quantificateurs vus pr√©c√©demment, on peut utiliser des accolades pour d√©finir explicitement combien de fois
un caract√®re peut √™tre r√©p√©t√©. Trois syntaxes sont disponibles :

    -   {n}     :   le caract√®re est r√©p√©t√© n fois
    -   {n,m}  :   le caract√®re est r√©p√©t√© de n √† m fois. 
    -   {n,}    :   le caract√®re est r√©p√©t√© de n fois √† l'infini

Si la tartiflette peut contenir un, deux ou trois t, la regex peut s'√©crire :

/tartiflet{1,3}e/

Ou encore :

/racle[tf]+e/       recherchera raclette, racleffe, racletfe, raclefte, racletttttttttttte, etc.

Voici un tableau avec quelques exemples de regex :

Cha√Æne                  |   Regex                            |   R√©sultat
--------------------------------------------------------------------------------------
Hellowwwwwwwww          |   /Hellow+/                        |   true
Goooooooogle            |   /G{2,}gle/                       |   true
Le 1er septembre        |   /Le [1-9][a-z]{2,3} septembre/   |   true
Le 1er septembre        |   /Le [1-9][a-z]{2,3}[a-z]+/       |   false
--------------------------------------------------------------------------------------

La derni√®re regex est fausse parce que l'espace n'a pas √©t√© sp√©cifi√© (l'espace entre "1er" et "septembre").

V./ Les m√©tacaract√®res

1.) Echapper les faux m√©tacaract√®res

Les caract√®res sp√©ciaux comme ^, $, [ et ], ou encore + et *. Ces caract√®res sont ce que l'on appelle des m√©tacaract√®res,
en voici la liste compl√®te :

!^$()[]{}?+*./\|

Un probl√®me se pose si l'on veut chercher la pr√©sence d'une accolade dans une cha√Æne de caract√®res. Eh bien il faudra, l√†
aussi, l'√©chapper avec anti-slash.

/accolade \{comme ceci\}/

De cette mani√®re, les accolades seront vus par l'interpr√©teur comme √©tant des accolades "dans le texte", et non comme
des m√©tacaract√®res. Il en va de m√™me pour tous les m√©tacaract√®res cit√©s pr√©c√©demment. 

Il faut m√™me penser √† √©chapper l'anti-slash avec... un anti-slash :

/\/un slash et un anti-slash \\/

2.) Les m√©tacaract√®res au sein des classes

Au sein des classes, il n'y a pas besoin d'√©chapper les m√©tacaract√®res, √† l'exception des crochets ([]), du tiret (qui est
utilis√© pour d√©finir un intervalle) et de l'anti-slash (qui sert √† √©chapper).

Note : concernant le tiret, il y a une exception ==> il n'a pas besoin d'√™tre √©chapp√© s'il est plac√© en d√©but ou en fin
de classe.

Ainsi : 

/[a-z!?]/       ==> recherche un caract√®re de a √† z, ou les m√©tacaract√®res ! et ?

Et s'il faut trouver un slash ou un anti-slash, il ne faudra pas oublier de les faire √©chapper :

/[a-z\/\\]/

VI./ Types g√©n√©riques et assertions

1.) Les types g√©n√©riques

On a vu que les classes √©taient pratiques pour chercher un caract√®re au sein d'un groupe, ce qui permet de trouver un
caract√®re sans savoir au pr√©alable quel sera ce caract√®re. Seulement, utiliser des classes alourdit fortement la 
syntaxe des regex et les rend difficilement lisibles. Pour pallier ce petit souci, on va utiliser ce qu'on appelle les 
types g√©n√©riques. Certains parlent aussi de "classes raccourcies", mais ce terme n'est pas tout √† fait exact.

Les types g√©n√©riques s'√©crivent tous de la mani√®re suivante : \x, o√π x repr√©sente une lettre. Voici la liste de tous
les types g√©n√©riques :

________________________________________________________________________________________________
Type    |   Description
------------------------------------------------------------------------------------------------
\d      |   Trouve un caractËre d√©cimal (un chiffre)
\D      |   Trouve un caract√®re qui n'est pas un d√©cimal (donc qui n'est pas un chiffre)
\s      |   Trouve un caract√®re blanc
\S      |   Trouve un caract√®re qui n'est pas un caract√®re blanc
\w      |   Trouve un caractËre alphanumÈrique (underscore y compris) : <=>[a-zA-Z0-9_]
\W      |   Trouve un caractËre qui n'est pas un caractËre "de mot" : <=> [^a-zA-Z0-9_]
------------------------------------------------------------------------------------------------

En plus de cela, il existe les caract√®res de type "espace blanc" :

_______________________________________________________________
Type    |   Description
---------------------------------------------------------------
\n      |   Trouve un retour √† la ligne
\t      |   Trouve une tabulation
\r 		|	Retour de chariot
---------------------------------------------------------------

Ces deux caract√®res sont reconnus par le type g√©n√©rique \s (qui trouve n'importe quel espace blanc)

2.) Les assertions

Les assertions s'√©crivent comme les types g√©n√©riques, mais ne fonctionnent pas tout √† fait de la m√™me fa√ßon. Un type 
g√©n√©rique recherche un caract√®re, tandis qu'une assertion recherche entre deux caract√®res. 

Ce tableau pr√©sente les assertions :

_______________________________________________
Type    |   Description
-----------------------------------------------
\b      |   Trouve une limite de mot
\B      |   Ne trouve pas de limite de mot
-----------------------------------------------

Attention : Il faut juste faire attention avec l'utilisation de \b, car cette assertion reconna√Æt les caract√®res accentu√©s
comme des "limites de mots". Cela peut donc provoquer des comportements inattendus.

PETIT BEMOLE : 

Pour vÈrifier si deux lettres ou plus se rÈpËtent ou pas (gr‚ce aux quantificateurs), il faut utiliser des parenthËses. Par exemple, si l'on veut
reconnaÓtre "Ayayayayay", il faudra taper l'une des regex suivantes :

/Ay(ay)*/
/Ay(ay)?/
/Ay(ay)+/

Et si l'on veut empÍcher que ce soit des parenthËses capturantes, on met "?:" au dÈbut comme j'ai appris :

/Ay(?:ay)+/
/Ay(?:ay)?/
/Ay(?:ay)*/




-->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Les expressions r√©guli√®re (1/2)</title>
</head>
<body>
	<script>
		/*
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		    var myRegex = /zlatan√©/;
		    if(myRegex.test("Je l'ai zlatan√© quoi"))
		        alert('Zlatan√© oui !');
		    
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		    //Rechercher un mot
		    
		    if(/raclette/.test('Je mangerais bien une raclette'))
		        alert('Tiens, √ßa parle de raclette');
		    else
		        alert('Pas de raclette √† l\'horizon');
		    
		    //Ignorer la casse
		    
		    if(/Raclette/i.test('Je mangerais bien une raclette moi'))
		        alert('Raclette !');
		    else
		        alert('pas de raclette');
		    
		    //Rechercher plusieurs mots
		    if(/Raclette|Tartiflette|Fondue/i.test('Je mangerais aussi une tartiflette'))
		        alert('Tarfiflette ?!');
		    
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		    //D√©but et fin de cha√Æne
		    if(/^C'est bon|nul$/.test('C\'est bon'))
		        alert('Bon');
		    if(/^C'est bon|nul$/.test('Ce film est nul'))
		        alert('Nul');
		    
		    //Les intervalles de caract√®res
		    if(/gr[ao]s/.test('Il est un peu gros lui'))
		        alert('gros');
		    if(/gr[a-z]s[se]/.test('Ouai ma grose'))
		        alert('grose');
		    
		    //Les intervalles de chiffres
		    if(/[0-5]%/.test('Seulement 4% de voix contre'))
		        alert('4%');
		    
		    //Les intervalles de chiffres et de lettres
		    if(/^C[0-9a-zA-Z]/.test('Ce BFMTv est nul'))
		        alert('Ce');
		    if(/^C[0-9a-zA-Z]/.test('CE SFR '))
		        alert('CE');
		    if(/^C[0-9a-zA-Z]/.test('C10'))
		        alert('C1');
		    
		    //Intervalles exclus
		    if(/sa[^l-o]op/.test('Quel sabop !'))
		        alert('sabop, pas salop');
		    if(/m[^ai]t/.test('met'))
		        alert('OK pour m[^ai]t trouvant met mais excluant mit');
		    //Trouver un caract√®re quelconque
		    if(/bl.nc/.test('Il est blanc comme la neige'))
		        alert('blanc');
		 */

		var result = /Pa(?:blo)?/.exec('Pabloblo');
		alert(result[0]);
		if(/\w/.test('√©√π√†√ß√®'))
			alert('OK');
			else
			alert('pas ok');
		
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Les quantificateurs

		if (/racl[e√®]tt?e/.test('Elle bonne cette racl√®te'))
			alert('racl√®te??!');
		if (/raclet+e/.test('Non, cette raclette voyons'))
			alert('Ah, raclette.');
		if (/raclet*e*/.test('Tu racles bien toi'))
			alert('racle');
		if (/raclet*e/.test('Une raclettttttttttttttte'))
			alert('racletttttttttttttte');

		//Les accolades
		if (/racle[tf]{1,3}e/.test('raclefte'))
			alert('raclefte');

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Les m√©tacaract√®res
		if (/[a-z\/\\]/.test('/'))
			alert('slash');
		if (/[a-z!?/\\]/.test('/'))
			alert('Au sein d\'une classe regex, il est facultatif d\'√©chapper un slash avec un anti-slash');
		if (/[!a-z?]/.test('!')) //trouve !, ? et les lettres minuscules
			alert('!');

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Les types g√©n√©riques et assertions
		//Les types g√©n√©riques
		if (/\d/.test('1'))
			alert('1');
		if (/co√ªte \d\w\s/.test('Ca co√ªte 3E '))
			alert('Un chiffre suivi d\'une lettre suivie d\'un espace blanc');

		//Les assertions
		if (/co√ªte\b un\B/.test('Combien co√ªte unE pomme ?'))
			alert('Limite de mot et pas de limite de mot');

		if (/co√ªte\b/.test('Cela co√ªte√©'))
			alert('\\b d√©rape lorsqu\'il s\'agit de caract√®res accentu√©s qu\'il prend pour des limites de mots');
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if(/accentu./.test('accentu√©'))
			alert('Le point trouve aussi les caract√®res accentu√©s !');
	</script>
</body>
</html>